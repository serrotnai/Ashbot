'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _https = require('https');

var _https2 = _interopRequireDefault(_https);

var _ws = require('ws');

var _ws2 = _interopRequireDefault(_ws);

var _listener = require('./listener');

var _listener2 = _interopRequireDefault(_listener);

var _connection = require('./connection');

var _connection2 = _interopRequireDefault(_connection);

var _log = require('./log');

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ws = void 0;

var Socket = function (_Connection) {
  _inherits(Socket, _Connection);

  function Socket() {
    _classCallCheck(this, Socket);

    return _possibleConstructorReturn(this, (Socket.__proto__ || Object.getPrototypeOf(Socket)).apply(this, arguments));
  }

  _createClass(Socket, [{
    key: 'connect',
    value: function connect(_ref) {
      var _ref$actionHost = _ref.actionHost,
          actionHost = _ref$actionHost === undefined ? 'play.pokemonshowdown.com' : _ref$actionHost,
          nickname = _ref.nickname,
          _ref$password = _ref.password,
          password = _ref$password === undefined ? null : _ref$password,
          _ref$chatroom = _ref.chatroom,
          chatroom = _ref$chatroom === undefined ? 'lobby' : _ref$chatroom,
          server = _ref.server,
          _ref$port = _ref.port,
          port = _ref$port === undefined ? 8000 : _ref$port,
          format = _ref.format;

      this.actionurl = {
        host: actionHost,
        port: null,
        path: '/~~' + server + ':' + port + '/action.php'
      };

      this.nickname = nickname;
      this.password = password;
      this.chatroom = chatroom;
      this.format = format;

      _log2.default.log('connecting to: ' + server + ':' + port);
      this.build('ws://' + server + ':' + port + '/showdown/websocket');

      _listener2.default.subscribe('challstr', this.login.bind(this));
      _listener2.default.subscribe('updateuser', this.onUpdateUser.bind(this));
      _listener2.default.subscribe('popup', this.relayPopup);
      // defined message type for calling from battles, etc.
      _listener2.default.subscribe('_send', this.send);
    }

    /**
     * Build your socket.
     *
     * @param  {String} addy The address of the socket.
     */

  }, {
    key: 'build',
    value: function build(addy) {
      ws = new _ws2.default(addy);

      ws.on('open', function () {
        _log2.default.log('Got open message from server\'s websocket.');
      });

      ws.on('message', this.handleMessage);

      ws.on('error', function (err) {
        if (err.code === 'ECONNREFUSED') {
          _log2.default.error('ECONNREFUSED when trying to connect to server at:\n' + addy + '\nAre you sure a server is running there?\nMake sure you have the official server installed and running.\n\n Using git (preferred):\n\n    git clone https://github.com/Zarel/Pokemon-Showdown.git\n    cd Pokemon-Showdown\n    npm start\n\nRunning this separately will reduce startup time and allow you to read\nserver logs for debugging.\n');
        }
      });
    }

    /**
     * this function will relay ANYTHING to the server, hope your message is
     * formatted right!
     *
     * @link https://github.com/Zarel/Pokemon-Showdown
     *
     * @param  {String} message [description]
     */

  }, {
    key: 'send',
    value: function send(message) {
      ws.send(message);
    }
  }, {
    key: 'close',
    value: function close(message) {
      ws.close(message);
      if (this.chat) {
        this.chat.destroy();
        this.chat = null;
      }
    }
  }, {
    key: 'exit',
    value: function exit() {
      ws.close();
    }

    /**
     * Logging in to the server
     *
     * @param  {challengekeyid} String  Needed as param to login server
     * @param  {challenge} String  i.e. challengestr. Needed as param to login server
     *
     * @return null
     */

  }, {
    key: 'login',
    value: function login(_ref2) {
      var _this2 = this;

      var _ref3 = _slicedToArray(_ref2, 2),
          challengekeyid = _ref3[0],
          challenge = _ref3[1];

      // console.log('responding to challenge.');
      // console.log(id, str);

      var requestOptions = {
        hostname: this.actionurl.host,
        port: this.actionurl.port,
        path: this.actionurl.path,
        agent: false
      };
      // console.log(requestOptions);
      var data = '';
      if (!this.password) {
        requestOptions.method = 'GET';
        requestOptions.path += '?act=getassertion&userid=' + encodeURI(this.nickname) + '&challengekeyid=' + challengekeyid + '&challenge=' + challenge;
      } else {
        requestOptions.method = 'POST';
        data = 'act=login&name=' + encodeURI(this.nickname) + '&pass=' + encodeURI(this.password) + '&challengekeyid=' + challengekeyid + '&challenge=' + challenge;
        requestOptions.headers = {
          'Content-Type': 'application/x-www-form-urlencoded',
          'Content-Length': data.length
        };
      }
      var req = _https2.default.request(requestOptions, function (res) {
        // console.log('looking at response.');
        res.setEncoding('utf8');
        var chunks = '';
        res.on('data', function (chunk) {
          chunks += chunk;
        });
        res.on('end', function () {
          if (chunks === ';') {
            _log2.default.error('failed to log in; nick ' + _this2.nickname + ' is registered - invalid or no password given.\n    Make sure the nickname in your package.json isn\'t already taken, or\n    Register your nickname on http://play.pokemonshowdown.com/ and add\n    "nickname" and "password" to your package.json file.');
            process.exit(-1);
          }
          if (chunks.length < 50) {
            _log2.default.error('failed to log in: ' + chunks);
            process.exit(-1);
          }
          if (chunks.indexOf('heavy load') !== -1) {
            _log2.default.error('the login server is under heavy load; trying again in one minute');
            process.exit(-1);
          }
          if (chunks.substr(0, 16) === '<!DOCTYPE html>') {
            _log2.default.error('Connection error 522; trying agian in one minute');
            process.exit(-1);
          }
          if (chunks.indexOf('|challstr|') >= 0) {
            _this2.handleMessage(chunks);
            return;
          }

          // GET requests: 'chunks' (the response) IS the assertion.
          // POST requests return JSON that contains the assertion.
          var assertion = chunks;
          try {
            chunks = JSON.parse(chunks.substr(1));
            if (chunks.actionsuccess && chunks.curuser.loggedin) {
              assertion = chunks.assertion;
            } else {
              _log2.default.error('could not log in; action was not successful: ' + chunks.assertion);
              _log2.default.debug(chunks);
              process.exit(-1);
            }
          } catch (err) {
            // probably nothing - probably tried to parse a GET request that ain't JSON
            // console.error('error trying to parse data:', err, chunks);
          }
          _this2.send('|/trn ' + _this2.nickname + ',0,' + assertion);
        });
      });

      req.on('error', function (err) {
        return _log2.default.error('login error: ' + err.stack);
      });

      if (data) {
        req.write(data);
      }
      return req.end();
    }
  }, {
    key: 'relayPopup',
    value: function relayPopup(args) {
      _log2.default.warn('Got a popup:');
      _log2.default.warn(args);
    }
  }, {
    key: 'onUpdateUser',
    value: function onUpdateUser(_ref4) {
      var _ref5 = _slicedToArray(_ref4, 2),
          nick = _ref5[0],
          status = _ref5[1];

      // this includes a 3rd parameter, i.e. "mysterycode". who knows.
      if (status !== '1') {
        // console.error(`failed to log in, still guest (status code ${status})`);
        return false;
      }
      if (nick !== this.nickname) {
        _log2.default.error('nickname was ', nick, ' expecting ', this.nickname);
        return false;
      }

      socket.send('|/join ' + this.chatroom);

      // also try to join a room according to our battle format
      if (this.format) socket.send('|/join ' + this.format);
      return true;
    }
  }]);

  return Socket;
}(_connection2.default);

var socket = new Socket();
exports.default = socket;