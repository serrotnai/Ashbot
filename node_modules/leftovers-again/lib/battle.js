'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _battlestore = require('./model/battlestore');

var _battlestore2 = _interopRequireDefault(_battlestore);

var _timer = require('./model/timer');

var _timer2 = _interopRequireDefault(_timer);

var _log = require('./log');

var _log2 = _interopRequireDefault(_log);

var _decisions = require('./decisions');

var _report = require('./report');

var _report2 = _interopRequireDefault(_report);

var _listener = require('./listener');

var _listener2 = _interopRequireDefault(_listener);

var _matchstatus = require('./reporters/matchstatus');

var _matchstatus2 = _interopRequireDefault(_matchstatus);

var _pokeutil = require('./pokeutil');

var _pokeutil2 = _interopRequireDefault(_pokeutil);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var timer = new _timer2.default();
// that's right...you're gonna forfeit if you don't decide in this amount of time
var forfeitTimeout = void 0;

/**
 * This class manages a single battle. It handles these tasks:
 * - maintaining battle state via its BattleStore
 * - managing the AI instance
 * - translating AI responses into server responses
 * - handling the end of the match
 */

var Battle = function () {
  /**
   * Construct a Battle instance.
   * @param  {String} bid The battle ID; essential for server communication
   * @param  {Connection} connection The connection instance to use for
   * sending and receiving messages.
   * @param  {string} botpath The path to the bot JS file to use. The file it
   * grabs will be found at leftovers-again/bots/[botpath].js
   *
   */
  function Battle(bid, bot) {
    var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    _classCallCheck(this, Battle);

    forfeitTimeout = timeout;
    // battle ID
    this.bid = bid;

    // Messages we want to handle, and their handlers.
    this.handlers = {
      // from the normal server
      teampreview: this.handleTeamPreview,
      request: this.handleRequest,
      turn: this.handleTurn,
      win: this.handleWin,
      callback: this.handleCallback,
      cant: this.handleCant,

      // special function for auditing yrself.
      ask4help: this.getHelp
    };

    this.bot = bot;
    this.store = new _battlestore2.default();

    this.prevStates = [];
  }

  /**
   * Getter for my bot instance
   * @return {object} An AI instance of the file located at the botpath
   */


  _createClass(Battle, [{
    key: 'myBot',
    value: function myBot() {
      return this.bot;
    }

    /**
     * Secret function for getting information, not just decisions, from your AI
     * instance. It sends a 'help' message to the server.
     *
     * This is very undocumented (and lazy!) so don't use it.
     */

  }, {
    key: 'getHelp',
    value: function getHelp() {
      if (this.bot.getHelp) {
        _listener2.default.relay('_send', this.bid + '|' + JSON.stringify(this.bot.getHelp(this.store.data())));
      }
    }

    /**
     * Send all server messages through to your battle store, then handle them
     * within this class. See this.handlers to see what we're handling.
     * @param  {string} type    The type of message.
     * @param  {array} message  The parameters to this message.
     */

  }, {
    key: 'handle',
    value: function handle(type, message) {
      // handle store stuff first!
      this.store.handle(type, message);

      if (this.handlers[type]) {
        this.handlers[type].apply(this, message);
      }
    }

    /**
     * Handles the 'team preview' message. This is the phase of matches where
     * you see your opponent's team and decide who you want to send out first.
     * Each bot must handle this message.
     *
     * @TODO is this necessary or should we do this in handleRequest?
     */

  }, {
    key: 'handleTeamPreview',
    value: function handleTeamPreview() {
      this.decide();
    }

    /**
     * Handles a request.
     *
     * For certain requests, we want to immediately request a decision from our
     * bot. These situations are:
     * teamPreview: This is a team preview request
     * forceSwitch: Due to moves / feinting, we must switch our active mon
     * @param  {string} json The request JSON
     *
     * @return {Boolean}  True if we had to make a decision; false otherwise
     */

  }, {
    key: 'handleRequest',
    value: function handleRequest(json) {
      var data = JSON.parse(json);

      // this is not a request, just data.
      // @TODO probably unnecessary
      if (!data.rqid) {
        return false;
      }

      // do what it says.
      // @TODO probably unnecessary
      if (data.wait) {
        return false;
      }

      if (data.teamPreview) {
        return false;
      }

      if (data.forceSwitch) {
        this.decide();
        return true;
      }
      return false;
    }

    /**
     * On a turn message, we need to make a decision.
     *
     * @param that I'm ignoring: the turn number.
     */

  }, {
    key: 'handleTurn',
    value: function handleTurn(turn) {
      // eslint-disable-line
      this.decide();
    }

    /**
     * Handle a win
     *
     * @param  {String} nick  The nickname of the winner.
     *
     */

  }, {
    key: 'handleWin',
    value: function handleWin(nick) {
      timer.ping(); // don't worry about timeout anymore
      var winner = _pokeutil2.default.toId(nick);
      _log2.default.log(winner + ' won. ' + (winner === this.store.myNick ? '(that\'s you!)' : ''));
      _report2.default.win(winner, this.store, this.bid);

      _listener2.default.relay('_battleReport', {
        winner: winner,
        opponent: this.store.yourNick
      });
    }
  }, {
    key: 'handleCallback',
    value: function handleCallback(desc, code) {
      _log2.default.error('cb: ' + desc + ' ' + code);
      if (desc === 'trapped') {
        var state = this.store.data();
        state.self.reserve.forEach(function (mon) {
          mon.dead = true; // this is kind of hacky...
          mon.disabled = true; // better
        });
        this.decide(state);
      } else {
        _log2.default.error('Bailing');
        this.forfeit();
      }
    }

    /**
     * Handles the cant message.
     *
     * Sometimes we get this because the user chose an invalid option. This is
     * bad and we want to let the user know.
     *
     * Sometimes we get this because the move failed. For this, we just log to
     * events and do nothing. The server sends "reasons" and we keep a list of
     * reasons that we're expecting in the normal course of play.
     *
     * > The PokÃ©mon `POKEMON` could not perform a move because of the indicated
     * > `REASON` (such as paralysis, Disable, etc). Sometimes, the move it was
     * > trying to use is given.
     *
     * @param  {String} target [description]
     * @param  {String} reason [description]
     * @param  {String} move [description]
     *
     */

  }, {
    key: 'handleCant',
    value: function handleCant(target, reason, move) {
      _log2.default.info('got \'cant\' msg back from server. target:' + target + ' reason:' + reason);
      // 'soft' cants; don't need to do anything
      if (['slp', 'par', 'flinch', 'frz', 'Truant'].indexOf(reason) >= 0) {
        _log2.default.info('Normal-lookin reason');
        return;
      }

      var targetMon = this.store.barn.find(target);
      // Log.error('I think this guy was the target?');
      // Log.error(JSON.stringify(targetMon));

      //  HEAD
      //     if (!move && targetMon.disabled) {
      //       Log.error(`You tried to switch into ${target} but 'disabled' was true.`);
      //       Log.error('Check that property before you switch!');
      //     } else if (!move && targetMon.dead) {
      //       Log.error(`You tried to switch into ${target} but 'dead' was true.`);
      //       Log.error('Check that property before you switch!');
      //     } else if (move) {
      //       Log.error(`Move ${move} was unusable by ${target}.`);
      //       const targetMove = targetMon.moves.find(mv => mv.id.indexOf(move) >= 0);
      //       if (targetMove) {
      //         Log.error(JSON.stringify(targetMove));
      //         // @TODO disabling
      //       }
      //     }
      //     Log.error('forfeiting due to cant.');
      //     this.forfeit();
      // =======

      if (this.store.myId === targetMon.owner) {
        if (move) {
          _log2.default.error('Move ' + move + ' was unusable by ' + target + '.');
          var targetMove = targetMon.moves.find(function (mv) {
            return mv.id.indexOf(move) >= 0;
          });
          if (targetMove) {
            _log2.default.error(JSON.stringify(targetMove));
            // @TODO disabling
            // eh, just gonna forfeit.
            this.forfeit();
          }
        } else if (targetMon.disabled) {
          _log2.default.error('You tried to switch into ' + target + ' but \'disabled\' was true.');
          _log2.default.error('Check that property before you switch!');
          this.forfeit();
        } else if (targetMon.dead) {
          _log2.default.error('You tried to switch into ' + target + ' but \'dead\' was true.');
          _log2.default.error('Check that property before you switch!');
          this.forfeit();
        }
      }
      return;
    }

    /**
     * Asks the AI to make a decision, then sends it to the server.
     *
     */

  }, {
    key: 'decide',
    value: function decide(state) {
      var _this = this;

      timer.ping();

      if (!state) {
        state = this.store.data();
      }

      _log2.default.debug('STATE:');
      _log2.default.debug(JSON.stringify(state));

      _matchstatus2.default.report(state);

      _log2.default.toFile('lastknownstate-' + this.bid + '.log', JSON.stringify(state) + '\n');

      // attach previous states
      state.prevStates = this.prevStates;

      try {
        var choice = this.myBot().decide(state);

        if (choice instanceof Promise) {
          // wait for promises to resolve
          choice.then(function (resolved) {
            var res = _this.formatMessage(_this.bid, resolved, state);
            if (res) {
              _log2.default.info(res);
              _listener2.default.relay('_send', res);
            }

            // saving this state for future reference
            _this.prevStates.unshift(_this.abbreviateState(state));
          }, function (err) {
            _log2.default.err('I think there was an error here.');
            _log2.default.err(err);
          });
        } else {
          // message is ready to go
          var res = this.formatMessage(this.bid, choice, state);
          if (res) {
            _log2.default.info(res);
            _listener2.default.relay('_send', res);
          }

          // saving this state for future reference
          this.prevStates.unshift(this.abbreviateState(state));
        }

        // only if user set a timeout
        if (forfeitTimeout) {
          timer.after(function () {
            // @TODO fuck this
            _log2.default.error('Haven\'t heard from the server in forever! Cowardly bailing');
            _this.forfeit();
            // process.exit();
          }, forfeitTimeout);
        }
      } catch (e) {
        _log2.default.error('Forfeiting because of the following error:');
        _log2.default.error(e);
        this.forfeit();
      }
    }

    /**
     * Give up.
     */

  }, {
    key: 'forfeit',
    value: function forfeit() {
      _log2.default.log('Forfeiting this match:', this.bid);
      _listener2.default.relay('_send', this.bid + '|/forfeit');
    }

    /**
     * The prevStates array that we send to the bots doesn't need a ton of detail.
     * Let's just send a couple important fields.
     *
     * @param  {Object} state  The state object sent to bots.
     * @return {[type]}        Fewer fields of that state object.
     */

  }, {
    key: 'abbreviateState',
    value: function abbreviateState(state) {
      return {
        turn: state.turn,
        self: {
          active: {
            hp: state.self.active.hp,
            hppct: state.self.active.hppct,
            statuses: state.self.active.statuses
          }
        },
        opponent: {
          active: {
            hp: state.opponent.active.hp,
            hppct: state.opponent.active.hppct,
            statuses: state.opponent.active.statuses
          }
        }
      };
    }

    /**
     * Formats the message into something we can send to the server.
     *
     * @param  {string} bid    The battle ID
     * @param  {Choice} choice The choice we made. Choice must be an Object of
     * type MOVE or SWITCH.
     * @param  {BattleState} state  The current battle state.
     *
     * @return {string} The string to send to the server.
     *
     * @see __constructor
     */

  }, {
    key: 'formatMessage',
    value: function formatMessage(bid, choice, state) {
      _log2.default.debug('choice: ' + JSON.stringify(choice));
      var verb = void 0;

      // if you're wondering why this 'if' statement is so wonky... it's technical debt!
      // in 0.7.7 and lower, you had to check instanceof. But that check doesn't work
      // so well when it comes to cross-compatibility. So I added the 'type' property
      // to 'choice' which is less error-prone.
      if (choice instanceof _decisions.MOVE || choice.type === 'move') {
        var moveIdx = this.lookupMoveIdx(state.self.active.moves, choice.id);
        if (moveIdx < 0) {
          this.forfeit();
          return '';
        }

        verb = '/move ' + (moveIdx + 1); // move indexes for the server are [1..4]

        if (state.self.active.canMegaEvo && choice.shouldMegaEvo) {
          verb += ' mega';
        }
      } else if (choice instanceof _decisions.SWITCH || choice.type === 'switch') {
        verb = state.teamPreview ? '/team' : '/switch';
        var monIdx = this.lookupMonIdx(state.self.reserve, choice.id);
        if (monIdx < 0) {
          this.forfeit();
          return '';
        }
        verb = verb + ' ' + (monIdx + 1); // switch indexes for the server are [1..6]
      }
      return bid + '|' + verb + '|' + state.rqid;
    }

    /**
     * Helper function for translating a move into the move index, which is what
     * the server needs from the move. Move index is in [0..3].
     *
     * @param  {array} moves The array of Move objects from which we're drawing.
     * @param  {mixed} idx   The 0-indexed numeric index, the Move object, or the
     * move ID (lowercased, no spaces) of the move we're choosing.
     *
     * @return {number} The move index.
     */

  }, {
    key: 'lookupMoveIdx',
    value: function lookupMoveIdx(moves, idx) {
      _log2.default.debug('moves:', moves);
      _log2.default.debug('idx:', idx);

      var answer = -1;
      if (typeof idx === 'number') {
        answer = idx;
      } else if ((typeof idx === 'undefined' ? 'undefined' : _typeof(idx)) === 'object') {
        answer = moves.indexOf(idx);
      } else if (typeof idx === 'string') {
        answer = moves.findIndex(function (move) {
          return move.id === idx;
        });
      }

      if (moves[answer].disabled) {
        _log2.default.error('You cant use the move ' + moves[answer].id + ' because it is disabled!');
        return -1;
      }
      return answer;
    }

    /**
     * Helper function for translating a switch into the switch index, which is
     * what the server needs from the switch. Switch index is in [0..5].
     *
     * @param  {array} mons The possible Pokemons.
     * @param  {mixed} idx  The numeric index, the Pokemon object, or the species
     * name (lowercased, no spaces) of the Pokemon we want to switch into.
     *
     * @return {number} The switch index.
     */

  }, {
    key: 'lookupMonIdx',
    value: function lookupMonIdx(mons, idx) {

      var answer = void 0;
      switch (typeof idx === 'undefined' ? 'undefined' : _typeof(idx)) {
        case 'number':
          answer = idx;
          break;
        case 'object':
          answer = mons.indexOf(idx);
          break;

        case 'string':
          answer = mons.findIndex(function (mon) {
            return mon.species === idx || mon.id === idx;
          });
          break;
        default:
          _log2.default.error('looking up mon... not a valid choice!', idx, mons);
          return -1;
      }

      var storeGuy = mons[answer];

      if (storeGuy.dead) {
        _log2.default.error('You cant pick a dead guy.');
        return -1;
      }
      if (storeGuy.disabled) {
        _log2.default.error('You cant pick a disabled guy.');
        return -1;
      }
      if (storeGuy.active) {
        _log2.default.error('You cant pick your active guy.');
        return -1;
      }
      return answer;
    }
  }]);

  return Battle;
}();

exports.default = Battle;