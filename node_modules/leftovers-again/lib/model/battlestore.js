'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // import Pokemon from 'model/pokemon';


var _side = require('./side');

var _side2 = _interopRequireDefault(_side);

var _pokebarn = require('./pokebarn');

var _pokebarn2 = _interopRequireDefault(_pokebarn);

var _pokeutil = require('../pokeutil');

var _pokeutil2 = _interopRequireDefault(_pokeutil);

var _log = require('../log');

var _log2 = _interopRequireDefault(_log);

var _weather = require('../constants/weather');

var _weather2 = _interopRequireDefault(_weather);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Store for tracking the status of the battle.
 *
 */
var BattleStore = function () {
  function BattleStore() {
    _classCallCheck(this, BattleStore);

    // The array of all Pokemons involved in the battle.
    this.allmon = [];

    this.barn = new _pokebarn2.default();

    this.forceSwitch = false;
    this.teamPreview = false;

    this.myId = null;

    this.lastmove = null;
    this.events = [];
    this.statuses = [];
    this.turn = 0;
    this.weather = _weather2.default.NONE;
    this.sides = [];

    this.handlers = {
      '-damage': this.handleDamage,
      teampreview: this.handleTeamPreview,
      move: this.handleMove,
      switch: this.handleSwitch,
      drag: this.handleSwitch,
      request: this.handleRequest,
      turn: this.handleTurn,
      faint: this.handleFaint,
      heal: this.handleHeal,
      player: this.handlePlayer,
      replace: this.handleReplace,
      '-fail': this.handleFail,
      '-miss': this.handleMiss,
      '-boost': this.handleBoost,
      '-unboost': this.handleUnboost,
      '-status': this.handleStatus,
      '-curestatus': this.handleCureStatus,
      '-weather': this.handleWeather,
      '-sidestart': this.handleSideStart,
      '-sideend': this.handleSideEnd,

      // same signature
      '-formechange': this.handleDetailsChange,
      'detailschange': this.handleDetailsChange
    };

    // NOT sent to user. temporary storage.
    this.names = {};
  }

  /**
   * Instead of listening directly to server messages, we instantiate a
   * BattleStore elsewhere and have whatever created this Store pass messages
   * along to this. This design is probably bad, but I did this so that we
   * can have one BattleStore associated with each Battle ID, and the
   * class instantiating BattleStore is responsible for routing battle
   * messages to the correct BattleStore.
   *
   * @param  {String} type    The message type.
   * @param  {Array} message  The parameters for that message.
   */


  _createClass(BattleStore, [{
    key: 'handle',
    value: function handle(type, message) {
      if (this.handlers[type]) {
        this.handlers[type].apply(this, message);
      }
    }
  }, {
    key: 'handleSwitch',
    value: function handleSwitch(ident, details, condition) {
      var pos = _pokeutil2.default.identToPos(ident);
      var former = this.barn.findByPos(pos);

      var mon = this.barn.findOrCreate(ident, details);
      mon.position = pos;
      mon.active = true;

      if (former) {
        former.position = null;
        former.active = false;
      }

      mon.useCondition(condition);
      mon.useDetails(details); // @TODO is this necessary?

      this.events.push({
        type: 'switch',
        player: _pokeutil2.default.identToOwner(ident),
        turn: this.turn,
        from: former ? former.species : null,
        frompos: mon.position,
        to: mon.species,
        topos: mon.position,
        condition: condition.replace('\\/', '/')
      });
    }

    /**
     * Handles a move that happened.
     *
     * Moves have updated information in the form of idents, so let's record
     * those here.
     *
     * We also record the move that happened in the events array in case anyone
     * wants to use them.
     *
     * @param  {String} actor The ident of the Pokemon who made a move.
     * @param  {String} move  The name of the move, ex. 'Stealth Rock'
     * @param  {[type]} target [description]
     * @return {[type]}        [description]
     */

  }, {
    key: 'handleMove',
    value: function handleMove(actor, move, target) {
      var actingMon = this.barn.find(actor);
      if (!actingMon) {
        _log2.default.error('battlestore.handleMove: couldnt find ' + actor + ' in this haystack:');
        this.barn.allmon.forEach(function (mon) {
          return _log2.default.error(mon.ident + '|' + mon.details);
        });
      } else {
        actingMon.recordMove(move);
      }
    }
  }, {
    key: 'handleReplace',
    value: function handleReplace(ident, details, condition) {
      this.barn.replace(ident, details, condition);
    }
  }, {
    key: 'handleMiss',
    value: function handleMiss(actor, target) {
      var lastmove = this.events[this.events.length - 1];
      lastmove.miss = true;
    }
  }, {
    key: 'handleFail',
    value: function handleFail(target) {
      var lastmove = this.events[this.events.length - 1];
      lastmove.miss = true;
    }
  }, {
    key: 'handleBoost',
    value: function handleBoost(target, stat, stage) {
      var mon = this.barn.find(target);
      mon.useBoost(stat, +stage);
    }
  }, {
    key: 'handleUnboost',
    value: function handleUnboost(target, stat, stage) {
      this.handleBoost(target, stat, -1 * +stage);
    }
  }, {
    key: 'handleStatus',
    value: function handleStatus(target, status) {
      var mon = this.barn.find(target);
      mon.addStatus(status);
    }
  }, {
    key: 'handleCureStatus',
    value: function handleCureStatus(target, status) {
      var mon = this.barn.find(target);
      mon.removeStatus(status);
    }
  }, {
    key: 'handleDamage',
    value: function handleDamage(target, condition, explanation) {
      var mon = this.barn.find(target);

      var move = void 0;
      // @TODO lazy implementation
      if (explanation) {
        move = {
          type: 'damage',
          turn: this.turn,
          from: explanation,
          topos: mon.position
        };
        this.events.push(move);
      } else {
        move = this.events[this.events.length - 1];
      }

      move.prevhp = mon.hp;
      move.prevcondition = mon.condition;

      mon.useCondition(condition);

      move.nexthp = mon.hp;
      move.nextcondition = mon.condition;
      if (mon.dead) {
        move.killed = true;
      }
      move.damage = move.prevhp - move.nexthp;
      move.damagepct = Math.round(100 * move.damage / mon.maxhp);

      // think I was using this to validate damage numbers
      // if (mon.maxhp !== 100 && move.damage > 20) {
      //   Log.toFile('damagerangetest', move.damage + ',');
      // }

      if (explanation && explanation.indexOf('[from] item:') >= 0) {
        var item = explanation.replace('[from] item: ', '');
        mon.setItem(item);
      }
    }
  }, {
    key: 'handleFaint',
    value: function handleFaint(ident) {
      var mon = this.barn.find(ident);
      if (!mon) {
        _log2.default.error('couldnt find that pokemon' + ident);
        _log2.default.error(JSON.stringify(this.barn.all()));
      }
      mon.useCondition('0 fnt');
    }

    // @TODO this is pretty much thte same as the damage function

  }, {
    key: 'handleHeal',
    value: function handleHeal(target, condition, explanation) {
      var mon = this.barn.find(target);
      mon.useCondition(condition);
      if (!mon.item && explanation && explanation.indexOf('[from] item:') >= 0) {
        var item = explanation.replace('[from] item: ', '');
        mon.setItem(item);
      }
    }

    /**
     * Saves the name of the player.
     *
     * @param  {String} id        The id of the player, ex. 'p1' or 'p2'
     * @param  {String} name      The name of the player, ex. '5nowden'
     * @param  {[type]} something  ignored
     */

  }, {
    key: 'handlePlayer',
    value: function handlePlayer(id, name, something) {
      //eslint-disable-line
      if (!name) return;
      this.names[id] = _pokeutil2.default.toId(name);
    }

    /**
     * Handles the turn message, i.e. what turn it is.
     *
     * We only use this for tracking 'what happened on what turn'.
     *
     * When we get this message, we also record the status of each active
     * Pokemon, in our statuses array.
     *
     * @param  {Number} x The turn number.
     */

  }, {
    key: 'handleTurn',
    value: function handleTurn(x) {
      var _this = this;

      this.turn = parseInt(x, 10);

      var isactive = function isactive(mon) {
        return !mon.dead && (!!mon.position || mon.active);
      };
      this.barn.all().filter(isactive).forEach(function (mon) {
        _this.statuses.push({
          turn: _this.turn,
          position: mon.position,
          condition: mon.condition,
          species: mon.species
          // boosts: mon.boosts || null
        });
      });
    }
    /**
     * Handles an incoming request. The one parameter to this is a string of
     * JSON, known as the request.
     *
     *  what does the request look like? WELL. These properties are all integrated
     *  into the {@link AI} object, so you probably want to look at that instead.
     *  But in case you're wondering what the actual data from the server looks
     *  like, keep reading.
     *
     *  {@link MoveData} objects here are limited and contain only 'move' (the
     *  move name, ex. 'Fake Out', 'id' ex. 'fakeout', 'pp', 'maxpp', 'target',
     *  and 'disabled'.
     *
     * {@link PokemonData} objects are limited and contain only 'ident', 'details',
     * 'condition', 'hp', 'maxhp', 'active', 'stats', 'moves', 'baseAbility',
     * 'item', 'pokeball', and 'canMegaEvo'.
     *
     * With most of this information, we may know the things already, ex. we
     * know if a Pokemon took damage or not. However there are lots of ways we
     * would get out of sync if we didn't accept and process all of this
     * information. So we do that.
     *
     * You'll notice the request does not contain information about the
     * opponent! It's left as an exercise to US to keep track of the opponent's
     * state.
     *
     * @param {String} json The string of JSON which makes up the request.
     *
     * @param {Array<Object>} json.active  An array containing the moves that
     * your active Pokemon can perform. The size of the array is the number of
     * active Pokemon on your side, ex. in Singles matches, the array length is 1.
     * @param {Array<MoveData>} json.active[].moves            (the 4 moves of your active pokemon)
     * @param {Array<Boolean>}  json.forceSwitch  booleans for each position that
     * needs to switch out. ex. [true] means it's a singles match and your mon
     * needs to switch out. [false, true] means it's a doubles match and your
     * second mon needs to switch out.
     * @param {Boolean} json.noCancel  Moves cannot be cancelled in the interval
     * between sending the move and the server receiving your opponent's move.
     * This is unused.
     * @param {String} json.rqid  The request ID. ex. '1' for the first turn, '2' for the second, etc.
     *          These don't match up perfectly with turns bc you may have to swap
     *          out pokemon if one dies, etc.
     * @param {Object} json.side
     * @param {String} json.side.id    either 'p1' or 'p2'
     * @param {String} json.side.name  your name
     * @param {Array<PokemonData>} json.side.pokemon   6 of them. they're the pokemon on yr side.
     * @param {Boolean} json.wait  True if this is not a request - just updated
     * information. The opponent needs to do something; ex. if their mon feinted
     * last turn, they need to choose a mon to send in. This is unused.
     */

  }, {
    key: 'handleRequest',
    value: function handleRequest(json) {
      var data = JSON.parse(json);
      // requests are the first place we figure out who we are.
      // -- plato
      if (!this.myId) {
        this.myId = data.side.id;
        this.yourId = this.myId === 'p1' ? 'p2' : 'p1';
      }

      if (data.side && data.side.pokemon) {
        // handle some stuff during the first request
        for (var i = 0; i < data.side.pokemon.length; i++) {
          var mon = data.side.pokemon[i];
          var ref = this.barn.findOrCreate(mon.ident, mon.details);
          // first round, we shouldn't have any active mon yet!
          // but the request DOES set the first pokemon in Reserve to active!
          // it's a property of the mon.
          // I think this is handled quite differently in the web client.
          if (data.teamPreview) delete mon.active;

          ref.assimilate(mon);
          ref.order = i;
        }
      }

      // need to know these later. update to false to replace stale info.
      this.forceSwitch = data.forceSwitch || false;
      this.teamPreview = data.teamPreview || false;

      if (data.rqid) {
        this.rqid = data.rqid;
      }

      if (data.active) {
        // process this later.
        this.activeData = data.active;
      }
    }
  }, {
    key: 'handleWeather',
    value: function handleWeather(weather) {
      this.weather = weather;
    }

    /**
     * ex. |-sidestart|p1: 5nowden4189|move: Stealth Rock
     * @param  {String} side   Which players id is it?
     * @param  {String} action What happened?
     */

  }, {
    key: 'handleSideStart',
    value: function handleSideStart(side, action) {
      _log2.default.warn('got side effect!', side, action);
      // ex. 'p1' or 'p2'
      var id = side.split(':').shift().trim();
      if (!this.sides[id]) {
        this.sides[id] = new _side2.default();
      }
      this.sides[id].digest(action);
    }

    /**
     * @param  {String} side   Which players id is it?
     * @param  {String} action What happened?
     */

  }, {
    key: 'handleSideEnd',
    value: function handleSideEnd(side, action) {
      // ex. 'p1' or 'p2'
      var id = side.split(':').shift().trim();
      if (!this.sides[id]) {
        return;
      }
      this.sides[id].remove(action);
    }

    /**
     * Forme change! This came up a lot with castform, probs some other pokes too.
     * ex: |-formechange|p2a: Castform|Castform-Sunny|[msg]|[from] ability: Forecast
     * ex: |detailschange|p2a: Charizard|Charizard-Mega-X, M
     * ex. |detailschange|p2a: Sabbs|Sableye-Mega, M
     *
     * @param  {String} ident  The id of the pokemon
     * @param  {String} species  The pokemon's new species
     * @param  {String} hpstatus Not sure, always seems to be [msg]
     * @param  {String} reason  Why did these details change?
     */

  }, {
    key: 'handleDetailsChange',
    value: function handleDetailsChange(ident, details, hpstatus, reason) {
      var updated = this.barn.replace(ident, details, null);
    }

    /**
     * Output function for getting an object representation of the current
     * battle.
     *
     * This is usually called right after 'handleRequest', because requests
     * usually mean we're trying to get the battle's state and make some
     * decisions based on it.
     *
     * This function has NO EFFECT on the store's internal state; this is
     * important for consistency!
     *
     * @return {Object} An object representing the battle's current state. See
     * the documentation in AI for a detailed description.
     *
     * @relation AI
     */

  }, {
    key: 'data',
    value: function data() {
      var _this2 = this;

      var output = {
        self: {},
        opponent: {}
      };
      // const output = _.clone(this.state, true);
      var dataGetter = function dataGetter(mon) {
        return mon.data();
      };
      var iamowner = function iamowner(mon) {
        return mon.owner === _this2.myId;
      };
      var youareowner = function youareowner(mon) {
        return mon.owner !== _this2.myId;
      };
      var isactive = function isactive(mon) {
        return !mon.dead && (!!mon.position || mon.active);
      };
      var byPosition = function byPosition(a, b) {
        return b.position - a.position;
      };
      var byOrder = function byOrder(a, b) {
        return a.order - b.order;
      };

      // use getState so we can filter out any crap.
      output.self.active = this.barn.all().filter(iamowner).filter(isactive).map(dataGetter).sort(byPosition);
      // @TODO thinking about trying this. why are there actives during teamPreview?
      // if (this.teamPreview) {
      //   output.self.active = [];
      // }

      output.opponent.active = this.barn.all().filter(youareowner).filter(isactive).map(dataGetter).sort(byPosition);
      output.self.reserve = this.barn.all().filter(iamowner).sort(byOrder).map(dataGetter);
      output.opponent.reserve = this.barn.all().filter(youareowner).sort(byOrder) // @TODO does this do anything
      .map(dataGetter);

      if (output.opponent.active.length > 0 && !output.opponent.active[0].owner) {
        _log2.default.warn('stop the presses! pokemon with no owner.');
        _log2.default.warn(output.opponent.active[0]);
        process.exit(-1);
      }

      if (output.self.active.length > 1) {
        _log2.default.warn('stop the presses! too many active pokemon');
        _log2.default.warn(output.self.active);
      }

      // this was causing some errors before. could use some more research...
      // @TODO why aren't we clearing out activeData?
      if (this.activeData && output.self.active.length === this.activeData.length) {
        for (var i = 0; i < this.activeData.length; i++) {
          // researching moves and copying them over
          var movesArr = this.activeData[i].moves;
          var updated = movesArr.map(function (move) {
            // eslint-disable-line
            return Object.assign(move, _pokeutil2.default.researchMoveById(move.id));
          });
          output.self.active[i].moves = updated;

          // for mega-evolution
          if (this.activeData[i].canMegaEvo) {
            output.self.active[i].canMegaEvo = this.activeData[i].canMegaEvo;
          }
        }
      }

      // compress arrays to singles
      if (output.self.active.length === 1) {
        output.self.active = output.self.active[0];
      }
      if (output.opponent.active.length === 1) {
        output.opponent.active = output.opponent.active[0];
      }

      if (this.forceSwitch) output.forceSwitch = true;
      if (this.teamPreview) output.teamPreview = true;

      output.rqid = this.rqid;
      output.turn = this.turn;
      output.weather = this.weather;

      if (this.sides[this.myId]) {
        output.self.side = this.sides[this.myId].data();
      }
      if (this.sides[this.yourId]) {
        output.opponent.side = this.sides[this.yourId].data();
      }

      return output;
    }

    /**
     * Returns your nickname.
     * @return {String} Your nickname.
     */

  }, {
    key: 'myNick',
    get: function get() {
      return this.names[this.myId];
    }

    /**
     * Returns the nickname of your opponent.
     * @return {String} Opponent's nickname.
     */

  }, {
    key: 'yourNick',
    get: function get() {
      if (this.myId === 'p1') return this.names.p2;
      if (this.myId === 'p2') return this.names.p1;
      return null;
    }
  }]);

  return BattleStore;
}();

exports.default = BattleStore;