'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // import listener from './listener';
// import socket from 'socket';


var _team = require('../team');

var _team2 = _interopRequireDefault(_team);

var _log = require('../log');

var _log2 = _interopRequireDefault(_log);

var _listener = require('../listener');

var _listener2 = _interopRequireDefault(_listener);

var _report = require('../report');

var _report2 = _interopRequireDefault(_report);

var _endofmatch = require('../reporters/endofmatch');

var _endofmatch2 = _interopRequireDefault(_endofmatch);

var _pokeutil = require('../pokeutil');

var _pokeutil2 = _interopRequireDefault(_pokeutil);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var updateTimeout = null;

var simultaneous = 5;
var activeMatches = new Set();

/**
 * Used for managing challenges to other users.
 */

var Challenger = function () {
  /**
   * Constructor.
   * @param  {boolean} scrappy Set to true if we want this user to challenge
   * everyone in the lobby and everyone who joins the lobby later.
   * @param  {String}  format  The type of match we're challenging
   * opponents to. By default, the challenge type used matches the 'format'
   * field of the bot's package.json
   *
   * @return Constructor
   */
  function Challenger(connection, botmanager, args) {
    _classCallCheck(this, Challenger);

    var format = args.format,
        scrappy = args.scrappy,
        matches = args.matches,
        results = args.results,
        nickname = args.nickname;

    this.connection = connection;
    this.botmanager = botmanager;

    // if user provided opponent, challenge him
    this.format = format;
    this.scrappy = scrappy;
    this.matches = matches;
    this.results = results;
    this.nickname = _pokeutil2.default.toId(nickname);

    if (!scrappy) {
      _log2.default.log('Your bot is set to accept challenges only - it will not start any battles.');
    }

    _listener2.default.subscribe('updatechallenges', this.onUpdateChallenges.bind(this));
    _listener2.default.subscribe('_battleReport', this.onBattleReport.bind(this));
    _listener2.default.subscribe('_lobbyUpdate', this.challengeSomeone.bind(this));

    // all the users we've seen
    this.users = {};
    this.challengesFrom = {};
    this.challengeTo = {};
  }

  /**
   * Find someone to challenge.
   * Running this on a timeout so that we don't challenge too frequently, and
   * so that we don't challenge multiple times if we get a burst of updates.
   *
   * @param  {Set} users The users set.
   */


  _createClass(Challenger, [{
    key: 'challengeSomeone',
    value: function challengeSomeone() {
      var _this = this;

      var users = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.users;

      this.users = users;
      if (!this.scrappy) return; // only scrappy users can issue challenges
      if (updateTimeout) return;
      if (activeMatches.size >= simultaneous) return;

      updateTimeout = setTimeout(function () {
        if (_this.outstandingChallenge) return;

        if (_this.scrappy) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = users[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var user = _step.value;

              if (_this.tryChallenge(user)) {
                _this.outstandingChallenge = true;
                break;
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }
        updateTimeout = null;
      }, 1000);
    }

    /**
     * Run some checks and then send a challenge.
     *
     * @param  {[type]} opponent The person to challenge.
     * @return {[type]}          True if we sent the challenge, false otherwise.
     */

  }, {
    key: 'tryChallenge',
    value: function tryChallenge(opponent) {
      if (_pokeutil2.default.toId(opponent) === this.nickname) {
        _log2.default.info('Not challenging ' + opponent + ' because that\'s me.');
        return false;
      }
      if (this.outstandingChallenge) {
        _log2.default.info('Not challenging ' + opponent + ' because I\'m already challenging someone.');
        return false;
      }

      if (activeMatches.has(opponent)) {
        _log2.default.info('Already playing a match with ' + opponent);
        return false;
      }

      if (this.challengesFrom && this.challengesFrom[opponent] || this.challengeTo && this.challengeTo[opponent]) {
        _log2.default.info('already have a challenge from this person: ' + opponent);
        return false;
      }

      this.challenge(opponent);
      return true;
    }

    /**
     * Remove all our listeners before you destroy this.
     *
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      _listener2.default.unsubscribe('updatechallenges', this.onUpdateChallenges);
      _listener2.default.unsubscribe('updateuser', this.onUpdateUser);
      _listener2.default.unsubscribe('_battleReport', this.onBattleReport);
      _listener2.default.unsubscribe('_battleStarted', this.onBattleStarted);
      _listener2.default.unsubscribe('_lobbyUpdate', this.challengeSomeone);
    }

    /**
     * [onBattleReport description]
     *
     * @param  {[type]} options.winner   [description]
     * @param  {[type]} options.opponent [description]
     * @return {[type]}                  [description]
     */

  }, {
    key: 'onBattleReport',
    value: function onBattleReport(_ref) {
      var _this2 = this;

      var winner = _ref.winner,
          opponent = _ref.opponent;

      _log2.default.info('winner:', winner, 'loser:', opponent);

      var battles = _report2.default.data().filter(function (match) {
        return match.you === opponent;
      });
      _endofmatch2.default.report(battles, this.results);

      // haven't hit limit yet; will rechallenge dudes if we feel like it
      if (this.matches === 0 || battles.length < this.matches) {
        if (this.scrappy) {
          _log2.default.warn('rechallenging ' + opponent);
          setTimeout(function () {
            _this2.challenge(_pokeutil2.default.toId(opponent));
          }, 1000);
        }
      } else {
        _log2.default.warn('Exiting after ' + this.matches + ' matches.');
        process.exit();
      }
    }

    /**
     * Handle the updatechallenges message. Accept any challenges.
     *
     * When challenging:
     * [ '{"challengesFrom":{},"challengeTo":{"to":"randumbmarten","format":"randombattle"}}' ]
     * When challenge was accepted:
     * [ '{"challengesFrom":{},"challengeTo":null}' ]
     *
     * @param  {String} msg A JSON string
     * @param {Object} msg.challengesFrom An object of received challenges.
     * These challenges are key:value pairs where key is the opponent's nickname
     * and value is the battle type.
     *
     * @param {Object} msg.challengeTo An object of issued challenges.
     * These challenges are key:value pairs where key is the opponent's nickname
     * and value is the battle type.
     *
     */

  }, {
    key: 'onUpdateChallenges',
    value: function onUpdateChallenges(msg) {
      var _this3 = this;

      var _JSON$parse = JSON.parse(msg),
          challengesFrom = _JSON$parse.challengesFrom,
          challengeTo = _JSON$parse.challengeTo;

      _log2.default.debug('updated challenges: ' + msg);
      this.challengesFrom = challengesFrom || {};
      this.challengeTo = challengeTo;
      if (!challengeTo) {
        _log2.default.debug('no outstanding challenges.');
        this.outstandingChallenge = false;
        if (this.scrappy) {
          this.challengeSomeone();
        }
      }
      Object.keys(challengesFrom).forEach(function (opponent) {
        var format = challengesFrom[opponent];
        // only accept battles of the type we're designed for
        if (Challenger.acceptable(format, _this3.botmanager.accepts)) {
          if (Challenger.requiresTeam(format)) _this3.sendTeam(opponent);
          _this3.connection.send('|/accept ' + opponent);
          activeMatches.add(opponent);
        }
      });

      // these were pre-existing challenges, so let's just pretend they
      // didn't happen.
      if (this.challengeTo && this.challengeTo.to && !this.outstandingChallenge) {
        _log2.default.debug('Deprecated code, did you want to cancel a preexisting challenge?');
        // this.cancelOutstandingChallenges();
      }
    }

    /**
     * Send a message to the server containing our team data.
     *
     * @param {String} opponent  The opponent's nickname. This is provided in
     * case you want to customize your team against specific opponents.
     *
     * @return {Boolean}  True if we did send the message; false otherwise
     */

  }, {
    key: 'sendTeam',
    value: function sendTeam(opponent) {
      var team = this.botmanager.team(opponent);
      if (team) {
        var utmString = new _team2.default(team).asUtm();
        _log2.default.info('sending team msg...', utmString);

        this.connection.send('|/utm ' + utmString);
      } else {
        _log2.default.error('team required but couldnt get one!');
        return false;
      }
      return true;
    }

    /**
     * Cancels outstanding challenges.
     */

  }, {
    key: 'cancelOutstandingChallenges',
    value: function cancelOutstandingChallenges() {
      if (this.challengeTo && this.challengeTo.to) {
        _log2.default.warn(' ~ cancelling a challenge with ' + this.challengeTo.to);
        this.connection.send('|/cancelchallenge ' + this.challengeTo.to);
      }
    }

    /**
     * [acceptable description]
     * @param  {String} challenge The match type we were challenged to
     * @param  {String} accepts  A comma-separated list of match types(?)
     * @return {Boolean} True if the bot will accept this challenge, false otherwise.
     */

  }, {
    key: 'challenge',


    /**
     * Send a challenge to this user; maybe load your bot to find its team.
     *
     * @TODO combine this with onUpdateChallenges functionality? ex. the logic
     * for utm is the same.
     *
     * @param {String} The nickname to challenge.
     */
    value: function challenge(nick) {
      var format = this.format;

      if (Challenger.requiresTeam(format)) this.sendTeam(nick);

      _log2.default.info('sending challenge... ' + nick + ' ' + format);
      this.connection.send('|/challenge ' + nick + ', ' + format);
      activeMatches.add(nick);
    }
  }], [{
    key: 'acceptable',
    value: function acceptable(challenge, accepts) {
      if (accepts === 'ALL') return true;
      return accepts.includes(challenge);
    }

    /**
     * @TODO this is a lazy implementation
     *
     * @param  {[type]} format [description]
     * @return {[type]}               [description]
     */

  }, {
    key: 'requiresTeam',
    value: function requiresTeam(format) {
      if (format === 'randombattle') {
        return false;
      }
      return true;
    }
  }]);

  return Challenger;
}();

exports.default = Challenger;